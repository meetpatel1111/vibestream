package com.vibestream.player.domain.scanner

import android.content.Context
import android.graphics.Bitmap
import android.media.MediaMetadataRetriever
import android.net.Uri
import android.os.Build
import android.provider.MediaStore
import androidx.work.*
import com.vibestream.player.data.database.dao.FolderDao
import com.vibestream.player.data.database.dao.MediaItemDao
import com.vibestream.player.data.database.entity.MediaItemEntity
import com.vibestream.player.data.model.MediaType
import com.vibestream.player.data.model.ScanEvent
import com.vibestream.player.domain.library.ScanOptions
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.ProducerScope
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import java.io.File
import java.io.FileOutputStream
import java.security.MessageDigest
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Media library scanner for discovering and analyzing media files
 */
@Singleton
class MediaLibraryScanner @Inject constructor(
    private val context: Context,
    private val mediaItemDao: MediaItemDao,\n    private val folderDao: FolderDao\n) {\n    \n    companion object {\n        private const val THUMBNAIL_SIZE = 320\n        private const val THUMBNAIL_QUALITY = 85\n        \n        // Supported media file extensions\n        private val VIDEO_EXTENSIONS = setOf(\n            \"mp4\", \"mkv\", \"avi\", \"mov\", \"wmv\", \"flv\", \"webm\", \"m4v\", \"3gp\", \"ts\", \"m2ts\", \"mpg\", \"mpeg\"\n        )\n        \n        private val AUDIO_EXTENSIONS = setOf(\n            \"mp3\", \"flac\", \"wav\", \"aac\", \"ogg\", \"opus\", \"m4a\", \"wma\", \"ape\", \"dsd\", \"dff\", \"dsf\"\n        )\n    }\n    \n    /**\n     * Scan media files from specified paths\n     */\n    fun scanPaths(\n        paths: List<String>,\n        options: ScanOptions = ScanOptions()\n    ): Flow<ScanEvent> = callbackFlow {\n        try {\n            send(ScanEvent.Started)\n            \n            val startTime = System.currentTimeMillis()\n            var processedCount = 0\n            var addedCount = 0\n            \n            // Discover all media files\n            val mediaFiles = discoverMediaFiles(paths, options)\n            val totalFiles = mediaFiles.size\n            \n            if (totalFiles == 0) {\n                send(ScanEvent.Completed(0, 0, System.currentTimeMillis() - startTime))\n                return@callbackFlow\n            }\n            \n            // Process files with controlled concurrency\n            val semaphore = Semaphore(options.maxConcurrency)\n            val jobs = mutableListOf<Job>()\n            \n            for (file in mediaFiles) {\n                val job = launch {\n                    semaphore.withPermit {\n                        try {\n                            send(ScanEvent.Progress(processedCount, totalFiles, file.absolutePath))\n                            \n                            val mediaItem = processMediaFile(file, options)\n                            if (mediaItem != null) {\n                                // Check if file already exists in database\n                                val existing = mediaItemDao.getByUri(file.toURI().toString())\n                                if (existing == null) {\n                                    mediaItemDao.insert(mediaItem)\n                                    send(ScanEvent.ItemFound(mediaItem.toMediaItem()))\n                                    addedCount++\n                                } else {\n                                    // Update existing item if file was modified\n                                    if (file.lastModified() > existing.dateModified) {\n                                        val updatedItem = mediaItem.copy(\n                                            id = existing.id,\n                                            playCount = existing.playCount,\n                                            lastPlayPosition = existing.lastPlayPosition,\n                                            lastPlayedAt = existing.lastPlayedAt\n                                        )\n                                        mediaItemDao.update(updatedItem)\n                                        send(ScanEvent.ItemUpdated(updatedItem.toMediaItem()))\n                                    }\n                                }\n                            }\n                            \n                            processedCount++\n                        } catch (e: Exception) {\n                            send(ScanEvent.Error(e.message ?: \"Unknown error\", file.absolutePath))\n                        }\n                    }\n                }\n                jobs.add(job)\n            }\n            \n            // Wait for all jobs to complete\n            jobs.joinAll()\n            \n            val duration = System.currentTimeMillis() - startTime\n            send(ScanEvent.Completed(processedCount, addedCount, duration))\n            \n        } catch (e: Exception) {\n            send(ScanEvent.Error(e.message ?: \"Scan failed\"))\n        }\n        \n        awaitClose { }\n    }\n    \n    /**\n     * Discover media files in specified paths\n     */\n    private suspend fun discoverMediaFiles(\n        paths: List<String>,\n        options: ScanOptions\n    ): List<File> = withContext(Dispatchers.IO) {\n        val mediaFiles = mutableListOf<File>()\n        \n        for (path in paths) {\n            val folder = File(path)\n            if (folder.exists() && folder.isDirectory) {\n                discoverInFolder(folder, mediaFiles, options)\n            }\n        }\n        \n        // Filter files\n        mediaFiles.filter { file ->\n            file.length() >= options.minFileSize &&\n            !isExcluded(file.absolutePath, options.excludePatterns) &&\n            (!options.excludeHidden || !file.isHidden)\n        }\n    }\n    \n    /**\n     * Recursively discover media files in a folder\n     */\n    private fun discoverInFolder(\n        folder: File,\n        mediaFiles: MutableList<File>,\n        options: ScanOptions\n    ) {\n        try {\n            val files = folder.listFiles() ?: return\n            \n            for (file in files) {\n                when {\n                    file.isDirectory && options.includeSubfolders -> {\n                        if (!options.excludeHidden || !file.isHidden) {\n                            discoverInFolder(file, mediaFiles, options)\n                        }\n                    }\n                    file.isFile && isMediaFile(file) -> {\n                        mediaFiles.add(file)\n                    }\n                }\n            }\n        } catch (e: SecurityException) {\n            // Skip folders we don't have permission to read\n        }\n    }\n    \n    /**\n     * Process a single media file and extract metadata\n     */\n    private suspend fun processMediaFile(\n        file: File,\n        options: ScanOptions\n    ): MediaItemEntity? = withContext(Dispatchers.IO) {\n        try {\n            val metadata = extractMetadata(file)\n            val mediaType = getMediaType(file)\n            \n            val thumbnailPath = if (options.extractThumbnails && mediaType == MediaType.VIDEO) {\n                generateThumbnail(file)\n            } else null\n            \n            val waveformPath = if (options.extractWaveforms && mediaType == MediaType.AUDIO) {\n                generateWaveform(file)\n            } else null\n            \n            val hash = if (file.length() < 50 * 1024 * 1024) { // Only hash files < 50MB\n                calculateFileHash(file)\n            } else null\n            \n            MediaItemEntity(\n                id = generateMediaId(file),\n                uri = file.toURI().toString(),\n                type = mediaType,\n                title = metadata.title ?: file.nameWithoutExtension,\n                album = metadata.album,\n                artist = metadata.artist,\n                albumArtist = metadata.albumArtist,\n                genre = metadata.genre,\n                trackNumber = metadata.trackNumber,\n                discNumber = metadata.discNumber,\n                year = metadata.year,\n                duration = metadata.duration,\n                bitrate = metadata.bitrate,\n                sampleRate = metadata.sampleRate,\n                channels = metadata.channels,\n                codecAudio = metadata.audioCodec,\n                codecVideo = metadata.videoCodec,\n                container = file.extension.lowercase(),\n                width = metadata.width,\n                height = metadata.height,\n                isHdr = metadata.isHdr,\n                rotation = metadata.rotation,\n                fileSize = file.length(),\n                dateAdded = System.currentTimeMillis(),\n                dateModified = file.lastModified(),\n                hash = hash,\n                folderId = file.parentFile?.absolutePath,\n                thumbnailPath = thumbnailPath,\n                waveformPath = waveformPath\n            )\n        } catch (e: Exception) {\n            null\n        }\n    }\n    \n    /**\n     * Extract metadata from media file\n     */\n    private fun extractMetadata(file: File): MediaMetadata {\n        val retriever = MediaMetadataRetriever()\n        \n        return try {\n            retriever.setDataSource(file.absolutePath)\n            \n            MediaMetadata(\n                title = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE),\n                artist = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST),\n                album = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM),\n                albumArtist = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUMARTIST),\n                genre = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_GENRE),\n                year = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_YEAR)?.toIntOrNull(),\n                trackNumber = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_CD_TRACK_NUMBER)?.toIntOrNull(),\n                discNumber = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DISC_NUMBER)?.toIntOrNull(),\n                duration = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)?.toLongOrNull() ?: 0L,\n                bitrate = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_BITRATE)?.toIntOrNull(),\n                sampleRate = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n                    retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_CAPTURE_FRAMERATE)?.toIntOrNull()\n                } else null,\n                width = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH)?.toIntOrNull(),\n                height = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT)?.toIntOrNull(),\n                rotation = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION)?.toIntOrNull() ?: 0\n            )\n        } catch (e: Exception) {\n            MediaMetadata()\n        } finally {\n            try {\n                retriever.release()\n            } catch (e: Exception) {\n                // Ignore\n            }\n        }\n    }\n    \n    /**\n     * Generate thumbnail for video files\n     */\n    private suspend fun generateThumbnail(file: File): String? = withContext(Dispatchers.IO) {\n        try {\n            val retriever = MediaMetadataRetriever()\n            retriever.setDataSource(file.absolutePath)\n            \n            val bitmap = retriever.getFrameAtTime(\n                2000000, // 2 seconds\n                MediaMetadataRetriever.OPTION_CLOSEST_SYNC\n            )\n            \n            retriever.release()\n            \n            if (bitmap != null) {\n                val thumbnailFile = getThumbnailFile(file)\n                val resizedBitmap = Bitmap.createScaledBitmap(\n                    bitmap,\n                    THUMBNAIL_SIZE,\n                    (THUMBNAIL_SIZE * bitmap.height) / bitmap.width,\n                    true\n                )\n                \n                FileOutputStream(thumbnailFile).use { out ->\n                    resizedBitmap.compress(Bitmap.CompressFormat.JPEG, THUMBNAIL_QUALITY, out)\n                }\n                \n                bitmap.recycle()\n                resizedBitmap.recycle()\n                \n                thumbnailFile.absolutePath\n            } else null\n        } catch (e: Exception) {\n            null\n        }\n    }\n    \n    /**\n     * Generate waveform for audio files (placeholder implementation)\n     */\n    private suspend fun generateWaveform(file: File): String? = withContext(Dispatchers.IO) {\n        // TODO: Implement actual waveform generation\n        // This would require audio decoding and analysis\n        null\n    }\n    \n    /**\n     * Calculate file hash for duplicate detection\n     */\n    private fun calculateFileHash(file: File): String? {\n        return try {\n            val digest = MessageDigest.getInstance(\"MD5\")\n            file.inputStream().use { input ->\n                val buffer = ByteArray(8192)\n                var bytesRead: Int\n                while (input.read(buffer).also { bytesRead = it } != -1) {\n                    digest.update(buffer, 0, bytesRead)\n                }\n            }\n            digest.digest().joinToString(\"\") { \"%02x\".format(it) }\n        } catch (e: Exception) {\n            null\n        }\n    }\n    \n    // Utility functions\n    \n    private fun isMediaFile(file: File): Boolean {\n        val extension = file.extension.lowercase()\n        return VIDEO_EXTENSIONS.contains(extension) || AUDIO_EXTENSIONS.contains(extension)\n    }\n    \n    private fun getMediaType(file: File): MediaType {\n        val extension = file.extension.lowercase()\n        return if (VIDEO_EXTENSIONS.contains(extension)) MediaType.VIDEO else MediaType.AUDIO\n    }\n    \n    private fun isExcluded(path: String, patterns: List<String>): Boolean {\n        return patterns.any { pattern ->\n            path.matches(Regex(pattern))\n        }\n    }\n    \n    private fun generateMediaId(file: File): String {\n        return \"media_${file.absolutePath.hashCode().toString(16)}\"\n    }\n    \n    private fun getThumbnailFile(file: File): File {\n        val thumbnailDir = File(context.cacheDir, \"thumbnails\")\n        thumbnailDir.mkdirs()\n        return File(thumbnailDir, \"${generateMediaId(file)}.jpg\")\n    }\n}\n\n/**\n * Media metadata container\n */\ndata class MediaMetadata(\n    val title: String? = null,\n    val artist: String? = null,\n    val album: String? = null,\n    val albumArtist: String? = null,\n    val genre: String? = null,\n    val year: Int? = null,\n    val trackNumber: Int? = null,\n    val discNumber: Int? = null,\n    val duration: Long = 0L,\n    val bitrate: Int? = null,\n    val sampleRate: Int? = null,\n    val channels: Int? = null,\n    val audioCodec: String? = null,\n    val videoCodec: String? = null,\n    val width: Int? = null,\n    val height: Int? = null,\n    val isHdr: Boolean = false,\n    val rotation: Int = 0\n)\n\n/**\n * Extension function to convert MediaItemEntity to MediaItem\n */\nfun MediaItemEntity.toMediaItem(): com.vibestream.player.data.model.MediaItem {\n    return com.vibestream.player.data.model.MediaItem(\n        id = id,\n        uri = uri,\n        type = type,\n        title = title,\n        album = album,\n        artist = artist,\n        albumArtist = albumArtist,\n        genre = genre,\n        trackNumber = trackNumber,\n        discNumber = discNumber,\n        year = year,\n        duration = duration,\n        bitrate = bitrate,\n        sampleRate = sampleRate,\n        channels = channels,\n        codecAudio = codecAudio,\n        codecVideo = codecVideo,\n        container = container,\n        width = width,\n        height = height,\n        isHdr = isHdr,\n        rotation = rotation,\n        fileSize = fileSize,\n        dateAdded = dateAdded,\n        dateModified = dateModified,\n        hash = hash,\n        folderId = folderId,\n        isFavorite = isFavorite,\n        rating = rating,\n        replayGainTrack = replayGainTrack,\n        replayGainAlbum = replayGainAlbum,\n        lyrics = lyrics,\n        thumbnailPath = thumbnailPath,\n        waveformPath = waveformPath,\n        lastPlayPosition = lastPlayPosition,\n        playCount = playCount,\n        lastPlayedAt = lastPlayedAt\n    )\n}"}, {"original_text": "", "replace_all": false}]